// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/node.proto

package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Inspired by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L82
// AttachedVolume describes a volume attached to a node
type AttachedVolume struct {
	// Name of the attached volume
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// DevicePath represents the device path where the volume should be available
	DevicePath string `protobuf:"bytes,2,opt,name=devicePath,proto3" json:"devicePath,omitempty"`
}

func (m *AttachedVolume) Reset()                    { *m = AttachedVolume{} }
func (m *AttachedVolume) String() string            { return proto.CompactTextString(m) }
func (*AttachedVolume) ProtoMessage()               {}
func (*AttachedVolume) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{0} }

func (m *AttachedVolume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AttachedVolume) GetDevicePath() string {
	if m != nil {
		return m.DevicePath
	}
	return ""
}

// Inspired by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L442
// ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config source for the Node.
type ConfigMapNodeConfigSource struct {
	// Namespace is the metadata.namespace of the referenced ConfigMap.
	// This field is required in all cases.
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name is the metadata.name of the referenced ConfigMap.
	// This field is required in all cases.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// UID is the metadata.UID of the referenced ConfigMap.
	// This field is forbidden in Node.Spec, and required in Node.Status.
	// +optional
	Uid string `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	// ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap.
	// This field is forbidden in Node.Spec, and required in Node.Status.
	// +optional
	ResourceVersion string `protobuf:"bytes,4,opt,name=resourceVersion,proto3" json:"resourceVersion,omitempty"`
	// KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the KubeletConfiguration structure
	// This field is required in all cases.
	KubeletConfigKey string `protobuf:"bytes,5,opt,name=kubeletConfigKey,proto3" json:"kubeletConfigKey,omitempty"`
}

func (m *ConfigMapNodeConfigSource) Reset()                    { *m = ConfigMapNodeConfigSource{} }
func (m *ConfigMapNodeConfigSource) String() string            { return proto.CompactTextString(m) }
func (*ConfigMapNodeConfigSource) ProtoMessage()               {}
func (*ConfigMapNodeConfigSource) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{1} }

func (m *ConfigMapNodeConfigSource) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ConfigMapNodeConfigSource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConfigMapNodeConfigSource) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ConfigMapNodeConfigSource) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

func (m *ConfigMapNodeConfigSource) GetKubeletConfigKey() string {
	if m != nil {
		return m.KubeletConfigKey
	}
	return ""
}

// Inspired by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L690
// Describe a container image
type ContainerImage struct {
	// Names by which this image is known.
	// e.g. ["k8s.gcr.io/hyperkube:v1.0.7", "dockerhub.io/google_containers/hyperkube:v1.0.7"]
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
	// The size of the image in bytes.
	// +optional
	SizeBytes int64 `protobuf:"varint,2,opt,name=sizeBytes,proto3" json:"sizeBytes,omitempty"`
}

func (m *ContainerImage) Reset()                    { *m = ContainerImage{} }
func (m *ContainerImage) String() string            { return proto.CompactTextString(m) }
func (*ContainerImage) ProtoMessage()               {}
func (*ContainerImage) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{2} }

func (m *ContainerImage) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *ContainerImage) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

// Inspired by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L831
// DaemonEndpoint contains information about a single Daemon endpoint.
type DaemonEndpoint struct {
	// Port number of the given endpoint.
	Port int32 `protobuf:"varint,1,opt,name=Port,proto3" json:"Port,omitempty"`
}

func (m *DaemonEndpoint) Reset()                    { *m = DaemonEndpoint{} }
func (m *DaemonEndpoint) String() string            { return proto.CompactTextString(m) }
func (*DaemonEndpoint) ProtoMessage()               {}
func (*DaemonEndpoint) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{3} }

func (m *DaemonEndpoint) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// Inspred by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L1763
// Node is a worker node in Kubernetes.
// Each node will have a unique identifier in the cache (i.e. in etcd).
type Node struct {
	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	// +optional
	// optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
	Metadata *ListMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// Spec defines the behavior of a node.
	// https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
	// +optional
	// optional NodeSpec spec = 2;
	Spec *NodeSpec `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	// Most recently observed status of the node.
	// Populated by the system.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
	// +optional
	// optional NodeStatus status = 3;
	Status *NodeStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{4} }

func (m *Node) GetMetadata() *ListMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Node) GetSpec() *NodeSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Node) GetStatus() *NodeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Inspired by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L1784
// NodeAddress contains information for the node's address.
type NodeAddress struct {
	// Node address type, one of Hostname, ExternalIP or InternalIP.
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// The node address.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *NodeAddress) Reset()                    { *m = NodeAddress{} }
func (m *NodeAddress) String() string            { return proto.CompactTextString(m) }
func (*NodeAddress) ProtoMessage()               {}
func (*NodeAddress) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{5} }

func (m *NodeAddress) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *NodeAddress) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// Inspired by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L1816
// NodeCondition contains condition information for a node.
type NodeCondition struct {
	// Type of node condition.
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Status of the condition, one of True, False, Unknown.
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// Last time we got an update on a given condition.
	// +optional
	// optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastHeartbeatTime = 3;
	LastHeartbeatTime *Time `protobuf:"bytes,3,opt,name=lastHeartbeatTime" json:"lastHeartbeatTime,omitempty"`
	// Last time the condition transit from one status to another.
	// +optional
	// optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
	LastTransitionTime *Time `protobuf:"bytes,4,opt,name=lastTransitionTime" json:"lastTransitionTime,omitempty"`
	// (brief) reason for the condition's last transition.
	// +optional
	Reason string `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
	// Human readable message indicating details about last transition.
	// +optional
	Message string `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *NodeCondition) Reset()                    { *m = NodeCondition{} }
func (m *NodeCondition) String() string            { return proto.CompactTextString(m) }
func (*NodeCondition) ProtoMessage()               {}
func (*NodeCondition) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{6} }

func (m *NodeCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *NodeCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *NodeCondition) GetLastHeartbeatTime() *Time {
	if m != nil {
		return m.LastHeartbeatTime
	}
	return nil
}

func (m *NodeCondition) GetLastTransitionTime() *Time {
	if m != nil {
		return m.LastTransitionTime
	}
	return nil
}

func (m *NodeCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *NodeCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Inspired by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L1841
// NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding metadata) must be non-nil.
type NodeConfigSource struct {
	// ConfigMap is a reference to a Node's ConfigMap
	ConfigMap *ConfigMapNodeConfigSource `protobuf:"bytes,2,opt,name=configMap" json:"configMap,omitempty"`
}

func (m *NodeConfigSource) Reset()                    { *m = NodeConfigSource{} }
func (m *NodeConfigSource) String() string            { return proto.CompactTextString(m) }
func (*NodeConfigSource) ProtoMessage()               {}
func (*NodeConfigSource) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{7} }

func (m *NodeConfigSource) GetConfigMap() *ConfigMapNodeConfigSource {
	if m != nil {
		return m.ConfigMap
	}
	return nil
}

// Inspred by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L1847
// NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.
type NodeConfigStatus struct {
	// Assigned reports the checkpointed config the node will try to use.
	// When Node.Spec.ConfigSource is updated, the node checkpoints the associated
	// config payload to local disk, along with a record indicating intended
	// config. The node refers to this record to choose its config checkpoint, and
	// reports this record in Assigned. Assigned only updates in the status after
	// the record has been checkpointed to disk. When the Kubelet is restarted,
	// it tries to make the Assigned config the Active config by loading and
	// validating the checkpointed payload identified by Assigned.
	// +optional
	Assigned *NodeConfigSource `protobuf:"bytes,1,opt,name=assigned" json:"assigned,omitempty"`
	// Active reports the checkpointed config the node is actively using.
	// Active will represent either the current version of the Assigned config,
	// or the current LastKnownGood config, depending on whether attempting to use the
	// Assigned config results in an error.
	// +optional
	Active *NodeConfigSource `protobuf:"bytes,2,opt,name=active" json:"active,omitempty"`
	// LastKnownGood reports the checkpointed config the node will fall back to
	// when it encounters an error attempting to use the Assigned config.
	// The Assigned config becomes the LastKnownGood config when the node determines
	// that the Assigned config is stable and correct.
	// This is currently implemented as a 10-minute soak period starting when the local
	// record of Assigned config is updated. If the Assigned config is Active at the end
	// of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is
	// reset to nil (use local defaults), the LastKnownGood is also immediately reset to nil,
	// because the local default config is always assumed good.
	// You should not make assumptions about the node's method of determining config stability
	// and correctness, as this may change or become configurable in the future.
	// +optional
	LastKnownGood *NodeConfigSource `protobuf:"bytes,3,opt,name=lastKnownGood" json:"lastKnownGood,omitempty"`
	// Error describes any problems reconciling the Spec.ConfigSource to the Active config.
	// Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local Assigned
	// record, attempting to checkpoint the payload associated with Spec.ConfigSource, attempting
	// to load or validate the Assigned config, etc.
	// Errors may occur at different points while syncing config. Earlier errors (e.g. download or
	// checkpointing errors) will not result in a rollback to LastKnownGood, and may resolve across
	// Kubelet retries. Later errors (e.g. loading or validating a checkpointed config) will result in
	// a rollback to LastKnownGood. In the latter case, it is usually possible to resolve the error
	// by fixing the config assigned in Spec.ConfigSource.
	// You can find additional information for debugging by searching the error message in the Kubelet log.
	// Error is a human-readable description of the error state; machines can check whether or not Error
	// is empty, but should not rely on the stability of the Error text across Kubelet versions.
	// +optional
	Error string `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *NodeConfigStatus) Reset()                    { *m = NodeConfigStatus{} }
func (m *NodeConfigStatus) String() string            { return proto.CompactTextString(m) }
func (*NodeConfigStatus) ProtoMessage()               {}
func (*NodeConfigStatus) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{8} }

func (m *NodeConfigStatus) GetAssigned() *NodeConfigSource {
	if m != nil {
		return m.Assigned
	}
	return nil
}

func (m *NodeConfigStatus) GetActive() *NodeConfigSource {
	if m != nil {
		return m.Active
	}
	return nil
}

func (m *NodeConfigStatus) GetLastKnownGood() *NodeConfigSource {
	if m != nil {
		return m.LastKnownGood
	}
	return nil
}

func (m *NodeConfigStatus) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Inspired by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L1897
// NodeDaemonEndpoints lists ports opened by daemons running on the Node.
type NodeDaemonEndpoints struct {
	// Endpoint on which Kubelet is listening.
	// +optional
	KubeletEndpoint *DaemonEndpoint `protobuf:"bytes,1,opt,name=kubeletEndpoint" json:"kubeletEndpoint,omitempty"`
}

func (m *NodeDaemonEndpoints) Reset()                    { *m = NodeDaemonEndpoints{} }
func (m *NodeDaemonEndpoints) String() string            { return proto.CompactTextString(m) }
func (*NodeDaemonEndpoints) ProtoMessage()               {}
func (*NodeDaemonEndpoints) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{9} }

func (m *NodeDaemonEndpoints) GetKubeletEndpoint() *DaemonEndpoint {
	if m != nil {
		return m.KubeletEndpoint
	}
	return nil
}

// Inspired by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L1904
// NodeList is the whole list of all Nodes which have been registered with master.
// message NodeList {
type NodeList struct {
	// Standard list metadata.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	// +optional
	// optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
	Metadata *ListMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// List of nodes
	Items []*Node `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
}

func (m *NodeList) Reset()                    { *m = NodeList{} }
func (m *NodeList) String() string            { return proto.CompactTextString(m) }
func (*NodeList) ProtoMessage()               {}
func (*NodeList) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{10} }

func (m *NodeList) GetMetadata() *ListMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *NodeList) GetItems() []*Node {
	if m != nil {
		return m.Items
	}
	return nil
}

// Inspred by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L1968
// NodeSpec describes the attributes that a node is created with.
type NodeSpec struct {
	// PodCIDR represents the pod IP range assigned to the node.
	// +optional
	PodCIDR string `protobuf:"bytes,1,opt,name=podCIDR,proto3" json:"podCIDR,omitempty"`
	// ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>
	// +optional
	ProviderID string `protobuf:"bytes,3,opt,name=providerID,proto3" json:"providerID,omitempty"`
	// Unschedulable controls node schedulability of new pods. By default, node is schedulable.
	// More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
	// +optional
	Unschedulable bool `protobuf:"varint,4,opt,name=unschedulable,proto3" json:"unschedulable,omitempty"`
	// If specified, the node's taints.
	// +optional
	Taints []*Taint `protobuf:"bytes,5,rep,name=taints" json:"taints,omitempty"`
	// If specified, the source to get node configuration from
	// The DynamicKubeletConfig feature gate must be enabled for the Kubelet to use this field
	// +optional
	ConfigSource *NodeConfigSource `protobuf:"bytes,6,opt,name=configSource" json:"configSource,omitempty"`
	// Deprecated. Not all kubelets will set this field. Remove field after 1.13.
	// see: https://issues.k8s.io/61966
	// +optional
	ExternalID string `protobuf:"bytes,2,opt,name=externalID,proto3" json:"externalID,omitempty"`
}

func (m *NodeSpec) Reset()                    { *m = NodeSpec{} }
func (m *NodeSpec) String() string            { return proto.CompactTextString(m) }
func (*NodeSpec) ProtoMessage()               {}
func (*NodeSpec) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{11} }

func (m *NodeSpec) GetPodCIDR() string {
	if m != nil {
		return m.PodCIDR
	}
	return ""
}

func (m *NodeSpec) GetProviderID() string {
	if m != nil {
		return m.ProviderID
	}
	return ""
}

func (m *NodeSpec) GetUnschedulable() bool {
	if m != nil {
		return m.Unschedulable
	}
	return false
}

func (m *NodeSpec) GetTaints() []*Taint {
	if m != nil {
		return m.Taints
	}
	return nil
}

func (m *NodeSpec) GetConfigSource() *NodeConfigSource {
	if m != nil {
		return m.ConfigSource
	}
	return nil
}

func (m *NodeSpec) GetExternalID() string {
	if m != nil {
		return m.ExternalID
	}
	return ""
}

// Inspired by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L1998
// NodeStatus is information about the current status of a node.
type NodeStatus struct {
	// Capacity represents the total resources of a node.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
	// +optional
	// map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
	Capacity map[string]*Quantity `protobuf:"bytes,1,rep,name=capacity" json:"capacity,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Allocatable represents the resources of a node that are available for scheduling.
	// Defaults to Capacity.
	// +optional
	// map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> allocatable = 2;
	Allocatable map[string]*Quantity `protobuf:"bytes,2,rep,name=allocatable" json:"allocatable,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// NodePhase is the recently observed lifecycle phase of the node.
	// More info: https://kubernetes.io/docs/concepts/nodes/node/#phase
	// The field is never populated, and now is deprecated.
	// +optional
	Phase string `protobuf:"bytes,3,opt,name=phase,proto3" json:"phase,omitempty"`
	// Conditions is an array of current observed node conditions.
	// More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	Conditions []*NodeCondition `protobuf:"bytes,4,rep,name=conditions" json:"conditions,omitempty"`
	// List of addresses reachable to the node.
	// Queried from cloud provider, if available.
	// More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	Addresses []*NodeAddress `protobuf:"bytes,5,rep,name=addresses" json:"addresses,omitempty"`
	// Endpoints of daemons running on the Node.
	// +optional
	DaemonEndpoints *NodeDaemonEndpoints `protobuf:"bytes,6,opt,name=daemonEndpoints" json:"daemonEndpoints,omitempty"`
	// Set of ids/uuids to uniquely identify the node.
	// More info: https://kubernetes.io/docs/concepts/nodes/node/#info
	// +optional
	NodeInfo *NodeSystemInfo `protobuf:"bytes,7,opt,name=nodeInfo" json:"nodeInfo,omitempty"`
	// List of container images on this node
	// +optional
	Images []*ContainerImage `protobuf:"bytes,8,rep,name=images" json:"images,omitempty"`
	// List of attachable volumes in use (mounted) by the node.
	// +optional
	VolumesInUse []string `protobuf:"bytes,9,rep,name=volumesInUse" json:"volumesInUse,omitempty"`
	// List of volumes that are attached to the node.
	// +optional
	VolumesAttached []*AttachedVolume `protobuf:"bytes,10,rep,name=volumesAttached" json:"volumesAttached,omitempty"`
	// Status of the config assigned to the node via the dynamic Kubelet config feature.
	// +optional
	Config *NodeConfigStatus `protobuf:"bytes,11,opt,name=config" json:"config,omitempty"`
}

func (m *NodeStatus) Reset()                    { *m = NodeStatus{} }
func (m *NodeStatus) String() string            { return proto.CompactTextString(m) }
func (*NodeStatus) ProtoMessage()               {}
func (*NodeStatus) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{12} }

func (m *NodeStatus) GetCapacity() map[string]*Quantity {
	if m != nil {
		return m.Capacity
	}
	return nil
}

func (m *NodeStatus) GetAllocatable() map[string]*Quantity {
	if m != nil {
		return m.Allocatable
	}
	return nil
}

func (m *NodeStatus) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *NodeStatus) GetConditions() []*NodeCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *NodeStatus) GetAddresses() []*NodeAddress {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *NodeStatus) GetDaemonEndpoints() *NodeDaemonEndpoints {
	if m != nil {
		return m.DaemonEndpoints
	}
	return nil
}

func (m *NodeStatus) GetNodeInfo() *NodeSystemInfo {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

func (m *NodeStatus) GetImages() []*ContainerImage {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *NodeStatus) GetVolumesInUse() []string {
	if m != nil {
		return m.VolumesInUse
	}
	return nil
}

func (m *NodeStatus) GetVolumesAttached() []*AttachedVolume {
	if m != nil {
		return m.VolumesAttached
	}
	return nil
}

func (m *NodeStatus) GetConfig() *NodeConfigStatus {
	if m != nil {
		return m.Config
	}
	return nil
}

// Inspired by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L2057
// NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
type NodeSystemInfo struct {
	// MachineID reported by the node. For unique machine identification
	// in the cluster this field is preferred. Learn more from man(5)
	// machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
	MachineID string `protobuf:"bytes,1,opt,name=machineID,proto3" json:"machineID,omitempty"`
	// SystemUUID reported by the node. For unique machine identification
	// MachineID is preferred. This field is specific to Red Hat hosts
	// https://access.redhat.com/documentation/en-US/Red_Hat_Subscription_Management/1/html/RHSM/getting-system-uuid.html
	SystemUUID string `protobuf:"bytes,2,opt,name=systemUUID,proto3" json:"systemUUID,omitempty"`
	// Boot ID reported by the node.
	BootID string `protobuf:"bytes,3,opt,name=bootID,proto3" json:"bootID,omitempty"`
	// Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
	KernelVersion string `protobuf:"bytes,4,opt,name=kernelVersion,proto3" json:"kernelVersion,omitempty"`
	// OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
	OsImage string `protobuf:"bytes,5,opt,name=osImage,proto3" json:"osImage,omitempty"`
	// ContainerRuntime Version reported by the node through runtime remote API (e.g. docker://1.5.0).
	ContainerRuntimeVersion string `protobuf:"bytes,6,opt,name=containerRuntimeVersion,proto3" json:"containerRuntimeVersion,omitempty"`
	// Kubelet Version reported by the node.
	KubeletVersion string `protobuf:"bytes,7,opt,name=kubeletVersion,proto3" json:"kubeletVersion,omitempty"`
	// KubeProxy Version reported by the node.
	KubeProxyVersion string `protobuf:"bytes,8,opt,name=kubeProxyVersion,proto3" json:"kubeProxyVersion,omitempty"`
	// The Operating System reported by the node
	OperatingSystem string `protobuf:"bytes,9,opt,name=operatingSystem,proto3" json:"operatingSystem,omitempty"`
	// The Architecture reported by the node
	Architecture string `protobuf:"bytes,10,opt,name=architecture,proto3" json:"architecture,omitempty"`
}

func (m *NodeSystemInfo) Reset()                    { *m = NodeSystemInfo{} }
func (m *NodeSystemInfo) String() string            { return proto.CompactTextString(m) }
func (*NodeSystemInfo) ProtoMessage()               {}
func (*NodeSystemInfo) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{13} }

func (m *NodeSystemInfo) GetMachineID() string {
	if m != nil {
		return m.MachineID
	}
	return ""
}

func (m *NodeSystemInfo) GetSystemUUID() string {
	if m != nil {
		return m.SystemUUID
	}
	return ""
}

func (m *NodeSystemInfo) GetBootID() string {
	if m != nil {
		return m.BootID
	}
	return ""
}

func (m *NodeSystemInfo) GetKernelVersion() string {
	if m != nil {
		return m.KernelVersion
	}
	return ""
}

func (m *NodeSystemInfo) GetOsImage() string {
	if m != nil {
		return m.OsImage
	}
	return ""
}

func (m *NodeSystemInfo) GetContainerRuntimeVersion() string {
	if m != nil {
		return m.ContainerRuntimeVersion
	}
	return ""
}

func (m *NodeSystemInfo) GetKubeletVersion() string {
	if m != nil {
		return m.KubeletVersion
	}
	return ""
}

func (m *NodeSystemInfo) GetKubeProxyVersion() string {
	if m != nil {
		return m.KubeProxyVersion
	}
	return ""
}

func (m *NodeSystemInfo) GetOperatingSystem() string {
	if m != nil {
		return m.OperatingSystem
	}
	return ""
}

func (m *NodeSystemInfo) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

// Inspired by https://github.com/kubernetes/api/blob/master/core/v1/generated.proto#L4289
// The node this Taint is attached to has the "effect" on
// any pod that does not tolerate the Taint.
type Taint struct {
	// Required. The taint key to be applied to a node.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Required. The taint value corresponding to the taint key.
	// +optional
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Required. The effect of the taint on pods
	// that do not tolerate the taint.
	// Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
	Effect string `protobuf:"bytes,3,opt,name=effect,proto3" json:"effect,omitempty"`
	// TimeAdded represents the time at which the taint was added.
	// It is only written for NoExecute taints.
	// +optional
	// optional k8s.io.apimachinery.pkg.apis.meta.v1.Time timeAdded = 4;
	TimeAdded *Time `protobuf:"bytes,4,opt,name=timeAdded" json:"timeAdded,omitempty"`
}

func (m *Taint) Reset()                    { *m = Taint{} }
func (m *Taint) String() string            { return proto.CompactTextString(m) }
func (*Taint) ProtoMessage()               {}
func (*Taint) Descriptor() ([]byte, []int) { return fileDescriptorNode, []int{14} }

func (m *Taint) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Taint) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Taint) GetEffect() string {
	if m != nil {
		return m.Effect
	}
	return ""
}

func (m *Taint) GetTimeAdded() *Time {
	if m != nil {
		return m.TimeAdded
	}
	return nil
}

func init() {
	proto.RegisterType((*AttachedVolume)(nil), "pb.AttachedVolume")
	proto.RegisterType((*ConfigMapNodeConfigSource)(nil), "pb.ConfigMapNodeConfigSource")
	proto.RegisterType((*ContainerImage)(nil), "pb.ContainerImage")
	proto.RegisterType((*DaemonEndpoint)(nil), "pb.DaemonEndpoint")
	proto.RegisterType((*Node)(nil), "pb.Node")
	proto.RegisterType((*NodeAddress)(nil), "pb.NodeAddress")
	proto.RegisterType((*NodeCondition)(nil), "pb.NodeCondition")
	proto.RegisterType((*NodeConfigSource)(nil), "pb.NodeConfigSource")
	proto.RegisterType((*NodeConfigStatus)(nil), "pb.NodeConfigStatus")
	proto.RegisterType((*NodeDaemonEndpoints)(nil), "pb.NodeDaemonEndpoints")
	proto.RegisterType((*NodeList)(nil), "pb.NodeList")
	proto.RegisterType((*NodeSpec)(nil), "pb.NodeSpec")
	proto.RegisterType((*NodeStatus)(nil), "pb.NodeStatus")
	proto.RegisterType((*NodeSystemInfo)(nil), "pb.NodeSystemInfo")
	proto.RegisterType((*Taint)(nil), "pb.Taint")
}

func init() { proto.RegisterFile("pb/node.proto", fileDescriptorNode) }

var fileDescriptorNode = []byte{
	// 1116 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcd, 0x6e, 0x1b, 0xb7,
	0x13, 0x87, 0xac, 0x8f, 0x48, 0x23, 0x7f, 0xf2, 0x6f, 0xfc, 0xb3, 0x35, 0xd2, 0xd4, 0x5d, 0x04,
	0x86, 0x11, 0xb4, 0x4e, 0xeb, 0x02, 0x85, 0x91, 0xf4, 0xa2, 0x5a, 0x41, 0x2b, 0x24, 0x69, 0x5d,
	0xda, 0xce, 0x9d, 0xda, 0x1d, 0xdb, 0x0b, 0x4b, 0xe4, 0x82, 0xa4, 0xdc, 0x28, 0xc7, 0xbe, 0x53,
	0xdf, 0xa0, 0x97, 0x3e, 0x45, 0x8f, 0x7d, 0x8d, 0x62, 0x48, 0xae, 0x76, 0x57, 0x96, 0x0f, 0xed,
	0x8d, 0xf3, 0x9b, 0xdf, 0x90, 0xc3, 0x99, 0xe1, 0x0c, 0x61, 0x23, 0x1f, 0xbf, 0x90, 0x2a, 0xc5,
	0xa3, 0x5c, 0x2b, 0xab, 0xd8, 0x5a, 0x3e, 0xde, 0x23, 0x68, 0x8a, 0x56, 0x78, 0x68, 0x6f, 0x27,
	0x1f, 0xbf, 0xd0, 0x68, 0xd4, 0x4c, 0x27, 0x81, 0x15, 0x0f, 0x61, 0x73, 0x60, 0xad, 0x48, 0x6e,
	0x30, 0x7d, 0xaf, 0x26, 0xb3, 0x29, 0x32, 0x06, 0x2d, 0x29, 0xa6, 0x18, 0x35, 0xf6, 0x1b, 0x87,
	0x3d, 0xee, 0xd6, 0xec, 0x29, 0x40, 0x8a, 0x77, 0x59, 0x82, 0x67, 0xc2, 0xde, 0x44, 0x6b, 0x4e,
	0x53, 0x41, 0xe2, 0xdf, 0x1b, 0xf0, 0xc9, 0xa9, 0x92, 0x57, 0xd9, 0xf5, 0x3b, 0x91, 0xff, 0xa4,
	0x52, 0xf4, 0xc2, 0xb9, 0x3b, 0x89, 0x3d, 0x81, 0x1e, 0xed, 0x62, 0x72, 0x91, 0x14, 0xdb, 0x96,
	0xc0, 0xe2, 0xbc, 0xb5, 0xca, 0x79, 0xdb, 0xd0, 0x9c, 0x65, 0x69, 0xd4, 0x74, 0x10, 0x2d, 0xd9,
	0x21, 0x6c, 0x15, 0x9e, 0xbf, 0x47, 0x6d, 0x32, 0x25, 0xa3, 0x96, 0xd3, 0x2e, 0xc3, 0xec, 0x39,
	0x6c, 0xdf, 0xce, 0xc6, 0x38, 0x41, 0xeb, 0x9d, 0x78, 0x83, 0xf3, 0xa8, 0xed, 0xa8, 0xf7, 0x70,
	0xba, 0xfd, 0xa9, 0x92, 0x56, 0x64, 0x12, 0xf5, 0x68, 0x2a, 0xae, 0x91, 0xed, 0x42, 0xdb, 0xb9,
	0x16, 0x35, 0xf6, 0x9b, 0x87, 0x3d, 0xee, 0x05, 0xba, 0x81, 0xc9, 0x3e, 0xe2, 0xf7, 0x73, 0x8b,
	0xc6, 0x39, 0xda, 0xe4, 0x25, 0x10, 0x3f, 0x83, 0xcd, 0xa1, 0xc0, 0xa9, 0x92, 0xaf, 0x65, 0x9a,
	0xab, 0x4c, 0x5a, 0xba, 0xd3, 0x99, 0xd2, 0xd6, 0x5d, 0xb6, 0xcd, 0xdd, 0x3a, 0xfe, 0x08, 0x2d,
	0x8a, 0x0c, 0x3b, 0x84, 0x2e, 0xa5, 0x24, 0x15, 0x56, 0x38, 0x7d, 0xff, 0x78, 0xfd, 0x28, 0x1f,
	0x1f, 0xbd, 0xcd, 0x8c, 0x7d, 0x87, 0x56, 0xf0, 0x85, 0x96, 0xed, 0x43, 0xcb, 0xe4, 0x98, 0xb8,
	0x03, 0x03, 0x8b, 0x76, 0x38, 0xcf, 0x31, 0xe1, 0x4e, 0xc3, 0x0e, 0xa0, 0x63, 0xac, 0xb0, 0x33,
	0xe3, 0x42, 0xd5, 0x3f, 0xde, 0x5c, 0x70, 0x1c, 0xca, 0x83, 0x36, 0x7e, 0x05, 0x7d, 0x42, 0x07,
	0x69, 0xaa, 0xd1, 0x18, 0x72, 0xcf, 0xce, 0xf3, 0x45, 0x8a, 0x69, 0xcd, 0x22, 0x78, 0x24, 0xbc,
	0x3a, 0x64, 0xa2, 0x10, 0xe3, 0xbf, 0x1a, 0xb0, 0x11, 0x72, 0x9a, 0x66, 0x96, 0x42, 0xbc, 0xca,
	0xfe, 0xff, 0x0b, 0x57, 0xbc, 0x79, 0x90, 0xd8, 0xb7, 0xb0, 0x33, 0x11, 0xc6, 0xfe, 0x88, 0x42,
	0xdb, 0x31, 0x0a, 0x7b, 0x91, 0x4d, 0x31, 0x78, 0xdb, 0x25, 0x6f, 0x49, 0xe6, 0xf7, 0x29, 0xec,
	0x04, 0x18, 0x81, 0x17, 0x5a, 0x48, 0xe3, 0x4e, 0x75, 0x86, 0xad, 0x25, 0xc3, 0x15, 0x1c, 0xf2,
	0x44, 0xa3, 0x30, 0x4a, 0x86, 0xb4, 0x07, 0x89, 0x6e, 0x38, 0x45, 0x63, 0xc4, 0x35, 0x46, 0x1d,
	0x7f, 0xc3, 0x20, 0xc6, 0x3f, 0xc3, 0xf6, 0xbd, 0xa2, 0x7d, 0x05, 0xbd, 0xa4, 0xa8, 0xe8, 0x90,
	0x81, 0x4f, 0xe9, 0xd8, 0x07, 0xcb, 0x9c, 0x97, 0xfc, 0xf8, 0x8f, 0x46, 0x6d, 0x47, 0x1f, 0x89,
	0xaf, 0xa0, 0x2b, 0x8c, 0xc9, 0xae, 0x25, 0xa6, 0x21, 0xf1, 0xbb, 0x45, 0xba, 0x6a, 0xfb, 0x2c,
	0x58, 0xec, 0x0b, 0xe8, 0x88, 0xc4, 0x66, 0x77, 0x18, 0x1c, 0x58, 0xcd, 0x0f, 0x1c, 0xf6, 0x12,
	0x36, 0x28, 0x1a, 0x6f, 0xa4, 0xfa, 0x55, 0xfe, 0xa0, 0x54, 0x1a, 0xa2, 0xbc, 0xda, 0xa8, 0x4e,
	0xa5, 0xb2, 0x47, 0xad, 0x95, 0x0e, 0x8f, 0xca, 0x0b, 0xf1, 0x39, 0xfc, 0x8f, 0x0c, 0xeb, 0xc5,
	0x6d, 0xd8, 0x77, 0xb0, 0x15, 0x5e, 0x52, 0x81, 0x85, 0xfb, 0x30, 0x3a, 0xaa, 0xce, 0xe6, 0xcb,
	0xd4, 0xf8, 0x02, 0xba, 0xb4, 0x29, 0xd5, 0xfb, 0xbf, 0x78, 0x0b, 0x4f, 0xa1, 0x9d, 0x59, 0x9c,
	0x52, 0x75, 0x35, 0x8b, 0x0a, 0xa0, 0x6d, 0xb8, 0x87, 0xe3, 0xbf, 0x1b, 0x7e, 0x5b, 0x7a, 0x1c,
	0x94, 0xe9, 0x5c, 0xa5, 0xa7, 0xa3, 0x21, 0x0f, 0x25, 0x5a, 0x88, 0xd4, 0xc8, 0x72, 0xad, 0xee,
	0xb2, 0x14, 0xf5, 0x68, 0x18, 0xfa, 0x4b, 0x05, 0x61, 0xcf, 0x60, 0x63, 0x26, 0x0d, 0x75, 0xc3,
	0xd9, 0x44, 0x8c, 0x27, 0xbe, 0xe0, 0xba, 0xbc, 0x0e, 0xb2, 0xcf, 0xa1, 0x43, 0x3d, 0xc3, 0x9a,
	0xa8, 0xed, 0xbc, 0xe9, 0xb9, 0x7a, 0x24, 0x84, 0x07, 0x05, 0x3b, 0x81, 0xf5, 0xa4, 0x12, 0x6f,
	0x57, 0x71, 0x0f, 0xe5, 0xa2, 0xc6, 0x24, 0x17, 0xf1, 0x83, 0x45, 0x2d, 0xc5, 0x64, 0x34, 0x2c,
	0x7a, 0x6d, 0x89, 0xc4, 0x7f, 0xb6, 0x01, 0xca, 0x27, 0xce, 0x4e, 0xa0, 0x9b, 0x88, 0x5c, 0x24,
	0x99, 0x9d, 0xbb, 0x9e, 0xd5, 0x3f, 0x7e, 0x52, 0x6f, 0x02, 0x47, 0xa7, 0x41, 0xfd, 0x5a, 0x5a,
	0x3d, 0xe7, 0x0b, 0x36, 0x1b, 0x40, 0x5f, 0x4c, 0x26, 0x2a, 0x11, 0xd6, 0xdd, 0xd4, 0x07, 0xf6,
	0xb3, 0x25, 0xe3, 0x41, 0xc9, 0xf0, 0xf6, 0x55, 0x1b, 0x2a, 0x9b, 0xfc, 0x46, 0x18, 0x0c, 0x91,
	0xf4, 0x02, 0xfb, 0x1a, 0x20, 0x29, 0x7a, 0x85, 0x89, 0x5a, 0x6e, 0xdf, 0x9d, 0xca, 0xcd, 0xbd,
	0x86, 0x57, 0x48, 0xec, 0x4b, 0xe8, 0x85, 0x76, 0x83, 0x45, 0x50, 0xb7, 0x0a, 0x8b, 0xd0, 0xb5,
	0x78, 0xc9, 0x60, 0x03, 0xd8, 0x4a, 0xeb, 0x45, 0x19, 0x02, 0xfc, 0xb8, 0x30, 0x5a, 0xaa, 0x59,
	0xbe, 0xcc, 0x67, 0x47, 0xd0, 0xa5, 0x61, 0x39, 0x92, 0x57, 0x2a, 0x7a, 0x54, 0x56, 0xaf, 0xbb,
	0xfa, 0xdc, 0x58, 0x9c, 0x92, 0x86, 0x2f, 0x38, 0xec, 0x39, 0x74, 0x32, 0x9a, 0x10, 0x26, 0xea,
	0x3a, 0xf7, 0x58, 0x68, 0x06, 0x95, 0xe1, 0xc1, 0x03, 0x83, 0xc5, 0xb0, 0x7e, 0xe7, 0x86, 0xa9,
	0x19, 0xc9, 0x4b, 0x83, 0x51, 0xcf, 0xcd, 0x92, 0x1a, 0x46, 0x8f, 0x28, 0xc8, 0xc5, 0xfc, 0x8d,
	0xa0, 0xdc, 0xb8, 0x3e, 0x93, 0xf9, 0x32, 0x95, 0x3a, 0x83, 0x2f, 0x9a, 0xa8, 0xbf, 0xb2, 0xb0,
	0x42, 0xfb, 0xf7, 0x9c, 0xbd, 0x11, 0x6c, 0xd4, 0x8a, 0x80, 0xe6, 0xeb, 0x2d, 0xce, 0xc3, 0xe3,
	0xa0, 0x25, 0x8b, 0xa1, 0x7d, 0x27, 0x26, 0x33, 0xac, 0x0e, 0x9b, 0x5f, 0x66, 0x42, 0xda, 0xcc,
	0xce, 0xb9, 0x57, 0xbd, 0x5c, 0x3b, 0x69, 0xec, 0xbd, 0x85, 0xed, 0xe5, 0x92, 0xf8, 0xef, 0xbb,
	0xc5, 0xbf, 0x35, 0x61, 0xb3, 0x1e, 0x71, 0x1a, 0xb5, 0x53, 0x91, 0xdc, 0x64, 0x12, 0x47, 0xc3,
	0xe2, 0xb3, 0xb0, 0x00, 0xe8, 0x71, 0x18, 0xc7, 0xbd, 0xbc, 0x2c, 0x1f, 0x47, 0x89, 0x50, 0xef,
	0x1f, 0x2b, 0x65, 0x17, 0x6f, 0x3b, 0x48, 0xf4, 0xae, 0x6f, 0x51, 0x4b, 0x9c, 0xd4, 0x3f, 0x0f,
	0x75, 0x90, 0xfa, 0x86, 0x32, 0x2e, 0x95, 0x61, 0x74, 0x14, 0x22, 0x3b, 0x81, 0xc7, 0x49, 0x91,
	0x6b, 0x3e, 0x93, 0x36, 0x9b, 0x2e, 0xbe, 0x21, 0x7e, 0x96, 0x3c, 0xa4, 0x66, 0x07, 0xb0, 0x19,
	0x3a, 0x60, 0x61, 0xf0, 0xc8, 0x19, 0x2c, 0xa1, 0xc5, 0xb7, 0xe5, 0x4c, 0xab, 0x0f, 0xf3, 0x82,
	0xd9, 0x2d, 0xbf, 0x2d, 0x55, 0x9c, 0x3e, 0x43, 0x2a, 0x47, 0x2d, 0x6c, 0x26, 0xaf, 0x7d, 0xe8,
	0xa2, 0x9e, 0xff, 0x0c, 0x2d, 0xc1, 0x54, 0x89, 0x42, 0x27, 0x37, 0x99, 0xc5, 0xc4, 0xce, 0x34,
	0x46, 0xe0, 0x68, 0x35, 0x2c, 0x56, 0xd0, 0x76, 0xbd, 0x6b, 0x45, 0x1e, 0x77, 0xab, 0x79, 0xec,
	0x85, 0xcc, 0x51, 0x90, 0xf1, 0xea, 0x0a, 0x13, 0x5b, 0x04, 0xd9, 0x4b, 0xec, 0x00, 0x7a, 0x74,
	0xf3, 0x41, 0x9a, 0x62, 0x7a, 0x6f, 0x52, 0x97, 0xaa, 0x71, 0xc7, 0x7d, 0x3d, 0xbf, 0xf9, 0x27,
	0x00, 0x00, 0xff, 0xff, 0x3d, 0x9c, 0x4c, 0xff, 0xb1, 0x0a, 0x00, 0x00,
}
